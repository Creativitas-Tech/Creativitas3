<h1>Array-Based Rhythm Generation with Index Expressions</h1>
<p>This document describes a set of compositional <strong>blocks</strong> for generating rhythmic patterns using array methods.
All examples assume a common model:</p>
<ul>
<li>Time is represented as a discrete index <code>i</code></li>
<li>Rhythms are generated by evaluating an expression per index</li>
<li>The result is typically a hit (<code>1</code>, <code>'x'</code>, <code>'K'</code>, etc.) or a rest (<code>0</code>, <code>'.'</code>)</li>
</ul>
<p>The canonical form is:</p>
<pre><code class="language-js">Array.from({ length: N }, (_, i) =&gt; expr(i))
</code></pre>
<p>or, conceptually:</p>
<pre><code class="language-js">expr(i =&gt; /* rhythm logic */)
</code></pre>
<hr>
<h2>Core Idea</h2>
<ul>
<li><code>i</code> is time</li>
<li><code>%</code> (modulo) defines structure</li>
<li>Boolean expressions select events</li>
<li>Continuous functions can be thresholded into discrete rhythms</li>
</ul>
<hr>
<h2>1. Single Modulo Patterns</h2>
<p><strong>Even subdivisions and grids</strong></p>
<pre><code class="language-js">expr(i =&gt; i % 8 === 0 ? 1 : '.')
</code></pre>
<ul>
<li>Produces a regular pulse every <code>n</code> steps</li>
<li>Useful for downbeats, clocks, or structural markers</li>
<li>Often used as a base layer for more complex logic</li>
</ul>
<hr>
<h2>2. Chained / Nested Modulo Conditions</h2>
<p><strong>Hierarchical periodicity</strong></p>
<pre><code class="language-js">expr(i =&gt; i % 8 % 3 === 0 ? 1 : '.')
</code></pre>
<ul>
<li>Intersects multiple periodic structures</li>
<li>Creates non-uniform spacing without lookup tables</li>
<li><code>% 8</code> defines a macro-cycle</li>
<li><code>% 3</code> filters events inside that cycle</li>
</ul>
<hr>
<h2>3. Explicit Index Sets (<code>includes</code>)</h2>
<p><strong>Discrete rhythmic masks</strong></p>
<pre><code class="language-js">expr(i =&gt; [0, 3, 4, 6].includes(i % 8) ? 1 : '.')
</code></pre>
<ul>
<li>Direct and readable</li>
<li>Useful for short, intentional patterns</li>
<li>Encourages thinking in terms of sets rather than formulas</li>
</ul>
<p>Tradeoff:</p>
<ul>
<li>Less generative</li>
<li>More literal</li>
</ul>
<hr>
<h2>4. Composite Modulo Intersections</h2>
<p><strong>Chinese-remainderâ€“like structures</strong></p>
<pre><code class="language-js">expr(i =&gt; i % 16 % 14 % 10 % 9 % 7 % 4 === 0 ? 1 : '.')
</code></pre>
<ul>
<li>Each modulo acts as a constraint</li>
<li>Only indices satisfying <em>all</em> constraints survive</li>
<li>Produces sparse, irregular but deterministic rhythms</li>
</ul>
<p>Characteristics:</p>
<ul>
<li>Long apparent cycle lengths</li>
<li>High structural coherence</li>
<li>Often perceived as non-looping</li>
</ul>
<hr>
<h2>5. Bitwise or Arithmetic Compositions</h2>
<p><strong>Intentional operator abuse</strong></p>
<pre><code class="language-js">expr(i =&gt; (i % 16 ^ i % 10) === 0 ? 1 : '.')
</code></pre>
<ul>
<li>XOR, AND, or arithmetic combinations introduce discontinuities</li>
<li>Useful for brittle, glitch-like rhythms</li>
<li>Less intuitive, more exploratory</li>
</ul>
<hr>
<h2>6. Continuous Signal Functions</h2>
<p><strong>Sampling a continuous function at discrete steps</strong></p>
<pre><code class="language-js">expr(i =&gt; Math.sin(i) &gt; 0.5 ? 1 : '.')
</code></pre>
<p>Variants:</p>
<pre><code class="language-js">expr(i =&gt; Math.sin(i * 0.3) &gt; 0 ? 1 : '.')
expr(i =&gt; Math.sin(i) * Math.sin(i / 3) &gt; 0.2 ? 1 : '.')
</code></pre>
<ul>
<li>Treats rhythm as a thresholded signal</li>
<li>Phase, frequency, and scaling control density</li>
<li>Blurs rhythm and modulation</li>
</ul>
<hr>
<h2>7. Probability-Weighted Expressions</h2>
<p><strong>Stochastic gating</strong></p>
<pre><code class="language-js">expr(i =&gt; (i % 4 === 0 &amp;&amp; Math.random() &lt; 0.6) ? 1 : '.')
</code></pre>
<ul>
<li>Combines deterministic structure with variation</li>
<li>Maintains meter while avoiding exact repetition</li>
</ul>
<hr>
<h2>8. Symbolic / Multi-Value Outputs</h2>
<p><strong>Beyond binary rhythms</strong></p>
<pre><code class="language-js">expr(i =&gt;
  i % 8 === 0 ? 'K' :
  i % 4 === 0 ? 'S' :
  '.'
)
</code></pre>
<ul>
<li>Single pass generates multi-voice patterns</li>
<li>Symbols can be mapped later to instruments or events</li>
<li>Encourages layered thinking without multiple arrays</li>
</ul>
<hr>
<h2>9. Masking and Complementation</h2>
<p><strong>Deriving new rhythms from existing ones</strong></p>
<pre><code class="language-js">let a = expr(i =&gt; i % 5 === 0 ? 1 : '.')
let b = expr(i =&gt; a[i] === '.' ? 1 : '.')
</code></pre>
<ul>
<li>Complements, inversions, and exclusions</li>
<li>Useful for interlocking parts or call-and-response</li>
</ul>
<hr>
<h2>10. Canonical Example</h2>
<pre><code class="language-js">expr(i =&gt; i % 8 % 3 === 0 ? 1 : '.')
</code></pre>
<p>Compact, deterministic, and representative of the overall approach.</p>
<hr>
<h2>Conceptual Summary</h2>
<ul>
<li>Index <code>i</code> represents time</li>
<li>Modulo defines form</li>
<li>Boolean logic creates structure</li>
<li>Thresholds convert functions into events</li>
</ul>

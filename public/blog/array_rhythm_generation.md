# Array-Based Rhythm Generation with Index Expressions

This document describes a set of compositional **blocks** for generating rhythmic patterns using array methods.
All examples assume a common model:

- Time is represented as a discrete index `i`
- Rhythms are generated by evaluating an expression per index
- The result is typically a hit (`1`, `'x'`, `'K'`, etc.) or a rest (`0`, `'.'`)

The canonical form is:

```js
Array.from({ length: N }, (_, i) => expr(i))
```

or, conceptually:

```js
expr(i => /* rhythm logic */)
```

---

## Core Idea

- `i` is time
- `%` (modulo) defines structure
- Boolean expressions select events
- Continuous functions can be thresholded into discrete rhythms

---

## 1. Single Modulo Patterns  
**Even subdivisions and grids**

```js
expr(i => i % 8 === 0 ? 1 : '.')
```

- Produces a regular pulse every `n` steps
- Useful for downbeats, clocks, or structural markers
- Often used as a base layer for more complex logic

---

## 2. Chained / Nested Modulo Conditions  
**Hierarchical periodicity**

```js
expr(i => i % 8 % 3 === 0 ? 1 : '.')
```

- Intersects multiple periodic structures
- Creates non-uniform spacing without lookup tables
- `% 8` defines a macro-cycle
- `% 3` filters events inside that cycle

---

## 3. Explicit Index Sets (`includes`)  
**Discrete rhythmic masks**

```js
expr(i => [0, 3, 4, 6].includes(i % 8) ? 1 : '.')
```

- Direct and readable
- Useful for short, intentional patterns
- Encourages thinking in terms of sets rather than formulas

Tradeoff:
- Less generative
- More literal

---

## 4. Composite Modulo Intersections  
**Chinese-remainderâ€“like structures**

```js
expr(i => i % 16 % 14 % 10 % 9 % 7 % 4 === 0 ? 1 : '.')
```

- Each modulo acts as a constraint
- Only indices satisfying *all* constraints survive
- Produces sparse, irregular but deterministic rhythms

Characteristics:
- Long apparent cycle lengths
- High structural coherence
- Often perceived as non-looping

---

## 5. Bitwise or Arithmetic Compositions  
**Intentional operator abuse**

```js
expr(i => (i % 16 ^ i % 10) === 0 ? 1 : '.')
```

- XOR, AND, or arithmetic combinations introduce discontinuities
- Useful for brittle, glitch-like rhythms
- Less intuitive, more exploratory

---

## 6. Continuous Signal Functions  
**Sampling a continuous function at discrete steps**

```js
expr(i => Math.sin(i) > 0.5 ? 1 : '.')
```

Variants:

```js
expr(i => Math.sin(i * 0.3) > 0 ? 1 : '.')
expr(i => Math.sin(i) * Math.sin(i / 3) > 0.2 ? 1 : '.')
```

- Treats rhythm as a thresholded signal
- Phase, frequency, and scaling control density
- Blurs rhythm and modulation

---

## 7. Probability-Weighted Expressions  
**Stochastic gating**

```js
expr(i => (i % 4 === 0 && Math.random() < 0.6) ? 1 : '.')
```

- Combines deterministic structure with variation
- Maintains meter while avoiding exact repetition

---

## 8. Symbolic / Multi-Value Outputs  
**Beyond binary rhythms**

```js
expr(i =>
  i % 8 === 0 ? 'K' :
  i % 4 === 0 ? 'S' :
  '.'
)
```

- Single pass generates multi-voice patterns
- Symbols can be mapped later to instruments or events
- Encourages layered thinking without multiple arrays

---

## 9. Masking and Complementation  
**Deriving new rhythms from existing ones**

```js
let a = expr(i => i % 5 === 0 ? 1 : '.')
let b = expr(i => a[i] === '.' ? 1 : '.')
```

- Complements, inversions, and exclusions
- Useful for interlocking parts or call-and-response

---

## 10. Canonical Example

```js
expr(i => i % 8 % 3 === 0 ? 1 : '.')
```

Compact, deterministic, and representative of the overall approach.

---

## Conceptual Summary

- Index `i` represents time
- Modulo defines form
- Boolean logic creates structure
- Thresholds convert functions into events
